{
  "name": "final-db",
  "version": "2.0.2",
  "description": "Embeded document based database system that uses bare file system as a storage. NoSql style.",
  "main": "index.js",
  "scripts": {
    "test": "jasmine-node ./spec/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:finalclass/finaldb.git"
  },
  "keywords": [
    "database",
    "document based",
    "map",
    "embedded",
    "filesystem",
    "nosql"
  ],
  "author": {
    "name": "Szymon Wygna≈Ñski",
    "email": "s@finalclass.net"
  },
  "license": "MIT",
  "dependencies": {
    "final-class": "0.0.x",
    "when": "2.1.x",
    "extend": "1.1.x",
    "final-fs": "1.4.x",
    "lockfile": "0.3.x"
  },
  "devDependencies": {
    "jasmine-node": "1.8.x"
  },
  "readme": "# Final-DB Embedded NoSQL database for nodejs platform.\n\n**MIT License** (see LICENSE.txt)\n\n- Final DB is a NoSQl database that uses file system as a storage.\n- It uses [when](https://github.com/cujojs/when) library for async calls.\n- It's totally asynchronous. No synchronous function is called in it's code.\n- Every async function returns a Promise. See [when](https://github.com/cujojs/when) documentation.\n- Uses [final-fs](https://github.com/finalclass/final-fs) library for file system manipulation.\n\n## Version 2\n\nVersion 2 does not support version 1 databases. Whole files organisation is rewriten to allow users to store\nmilions of documents.\n\nAlso there is benchmark available in benchmarks directory. Benchmark is set to run for 100 000 files.\nChange it if you want.\n\nAPI is not changed in version 2.\n\n## fdb.Collection constructor\n\nThe fdb.Collection constructor takes one argument: an object of options. However now there is only one option\nyou can specify: dirName. This option can be set as a string or an Array.\nIf you've specified dirName as an Array then path.resolve is called on this array.\n\nIf instead of specifying an object as an input to fdb.Collection you've specified a string or an array\nthen this argument is taken as a dirName.\n\nThese are valid instantiations of fdb.Collection:\n\n```js\nvar fdb = require('final-db');\n\nnew fdb.Collection({dirName: '/path/to/collection/files'});\n//or\nnew fdb.Collection({dirName: ['path', 'to', 'collection', 'files']});\n//or\nnew fdb.Collection('/path/to/collection/files');\n//or\nnew fdb.Collection(['path', 'to', 'collection', 'files']);\n```\n\n## Insert\n\n```js\nvar fdb = require('final-db'),\n    john = {name: 'John'},\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers.insert(john);\n//Now john.id and john.rev properties are available (these are generated randomly)\nusers.flush().then(function () {\n    //do something on finish\n});\n```\n\nWhen you run .flush() few thinks happen:\n\n- Check if directory dirName exists\n- If it's not this directory will be created\n- Next execute all the actions (.insert(), .update() or .remove()) in a sequnece (one after the other) (async of course:))\n- finally return a promise.\n\n## Update\n\n```js\nvar fdb = require('final-db'),\n    john = {id: 'sjwke234', name: 'JOHN'},\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers.update(john);\n//john.rev will change\nusers.flush().then(function () {\n    //do something on finish\n});\n```\n\nAfter doing flush, old version of updated record will be saved in a file located here:\ncollectionDir/recordId/revisionNumber.json\nSo you can revert any change any time.\n\n## Save\n\nSave method checks (by id) if record exists and if it's not executes insert but if record exists then executes update.\n\n```js\nvar fdb = require('final-db'),\n    john = {id: 'sjwke234', name: 'JOHN'},\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers\n    .save(john);\n    .flush().then(function () {\n        //do something on finish\n    });\n```\n\n## Remove\n\n```js\nvar fdb = require('final-db'),\n    john = {id: 'sjwke234'},\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers.remove(john);\nusers.flush().then(function () {\n    //do something on finish\n});\n```\n\n## Flush\n\nWhen you call `.flush()` the collection is locked and it's impossible for any other process to change it.\nWhen all jobs are finished (or if error occured) the collection is unlocked.\n\n## Find by id\n\n```js\nvar fdb = require('final-db'),\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers.find('userId').then(function (user) {\n    // we got user object now\n});\n```\n\n## Find all\n\n```js\nvar fdb = require('final-db'),\n    users = new fdb.Collection({dirName: __dirname + '/var'});\n\nusers.find().then(function (allUsers) {\n    // we got all users as array of objects now\n});\n```\n\n## More complex searches\n\nFor more complex search methods final-db uses maps. So set a map, and search by this map. This method is super fast\nand does not need to walk through all the records. It's just reading one file - it's how fast it is.\n\nThe only downside of this is that any insert / update / remove has to update the hash table stored on disk for the specific\nkey value. It's also very fast since it alteres only one file per map.\n\n## Map\n\nYou can set map function. This function is executed when new records are inserted / updated.\nIf you set a map and there is no map with the same name or the map with the same name\nhas different code then the map is rebuild. So be carefull when working with huge databases - it's\nimportant to know this fact.\n\nMap keys are converted to file name valid string with final-fs fileNameFilter function. Remember this when\ncreating keys.\n\n**Remember that you must emit in emit function!**\n\n###### Example: Create map and find by key in the map.\n\n```js\nvar fdb = require('final-db'),\n    path = require('path'),\n    cars = new fdb.Collection({dirName: path.resolve(__dirname, 'var', 'cars')});\n\ncars\n    .insert({mark: 'mercedes', model: 'A-class'})\n    .insert({makr: 'mercedes', model: 'B-class'})\n    .flush()\n    .then(function () {\n        return cars.map('model_by_mark', function (emit, record) {\n            emit(record.mark, record.model);\n        })\n    })\n    .then(function () {\n        return cars\n            .insert({mark: 'mercedes', model: 'C-class'})\n            .flush();\n    })\n    .then(function () {\n        return cars.find('model_by_mark', 'mercedes')\n    })\n    .then(function (modelsArray) {\n        //modelsArray === ['A-class', 'B-class', 'C-class']\n    })\n    .otherwise(function (err) {\n        //if some error occured in the async call chain then this function will run. See err for details\n    });\n```\n\nRemember that when you set a map and the map was previously set (even in different program execution) then the map is not rebuild.\nIn other words, every time you call function map on a collection it stores the map function in a file. Next time when it's\ncalled it checks if provided map function is different with the one stored in a file. If and only if it's different then\nthe map is rebuild (map function is beeing called on every record in a collection).\n\n### Emit function\n\nWhen setting a map function you have 2 arguments: emit function and object. Emit function takes 2 arguments:\nkey and value.\n\n- key is a hash key.\n- value is a value you want to save in the hash.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/finalclass/finaldb/issues"
  },
  "_id": "final-db@2.0.2",
  "dist": {
    "shasum": "678213a2642697e0215109e514c565ec1f509ab6"
  },
  "_from": "final-db@*",
  "_resolved": "https://registry.npmjs.org/final-db/-/final-db-2.0.2.tgz"
}
